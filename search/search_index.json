{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Sistema de visualiza\u00e7\u00e3o e analise de grafos Sistema b\u00e1sico para cria\u00e7\u00e3o de grafos manualmente ou atrav\u00e9s de arquivos Baixando o projeto Para baixar todo projeto: $ git clone https://github.com/Jhow-X/grafos.git Setup inicial no mesmo diret\u00f3rio do makefile rode: $ make venv caso n\u00e3o possua o python3-venv ler a documenta\u00e7\u00e3o Ap\u00f3s isso rode: $ source graf/bin/activate Para inicializar o ambiente virtual. Para importar as coisas necess\u00e1rias pra executar o c\u00f3digo, rode: $ make import com isso tudo estar\u00e1 setado e pronto para o funcionamento do projeto ent\u00e3o por fim rode: $ make run para iniciar o projeto Passando os dados Manualmente O sistema come\u00e7ar\u00e1 a pedir os v\u00e9rtices um a um para parar de inserir valores \u00e9 s\u00f3 digitar '$'(sem as aspas), depois come\u00e7ar\u00e1 a pedir a informa\u00e7\u00e3o das arestas e para parar fa\u00e7a igual anteriormente. Usando arquivos os valores s\u00e3o passados em um arquivo (preferencialmente txt ou csv) com os valores separados por v\u00edrgulas como no exemplo a baixo: 1,2 O sistema cria grafos direcionados e n\u00e3o direcionados com base na op\u00e7\u00e3o escolhida considerando o valor da esquerda como o vertice de sa\u00edda e o da direita como v\u00e9rtice de entrada. Grafos valorados Para criar grafos valorados apenas adicione uma coluna a mais com o valor do peso, como no exemplo a baixo: 1,2,40","title":"Home"},{"location":"#sistema-de-visualizacao-e-analise-de-grafos","text":"Sistema b\u00e1sico para cria\u00e7\u00e3o de grafos manualmente ou atrav\u00e9s de arquivos","title":"Sistema de visualiza\u00e7\u00e3o e analise de grafos"},{"location":"#baixando-o-projeto","text":"Para baixar todo projeto: $ git clone https://github.com/Jhow-X/grafos.git","title":"Baixando o projeto"},{"location":"#setup-inicial","text":"no mesmo diret\u00f3rio do makefile rode: $ make venv caso n\u00e3o possua o python3-venv ler a documenta\u00e7\u00e3o Ap\u00f3s isso rode: $ source graf/bin/activate Para inicializar o ambiente virtual. Para importar as coisas necess\u00e1rias pra executar o c\u00f3digo, rode: $ make import com isso tudo estar\u00e1 setado e pronto para o funcionamento do projeto ent\u00e3o por fim rode: $ make run para iniciar o projeto","title":"Setup inicial"},{"location":"#passando-os-dados","text":"","title":"Passando os dados"},{"location":"#manualmente","text":"O sistema come\u00e7ar\u00e1 a pedir os v\u00e9rtices um a um para parar de inserir valores \u00e9 s\u00f3 digitar '$'(sem as aspas), depois come\u00e7ar\u00e1 a pedir a informa\u00e7\u00e3o das arestas e para parar fa\u00e7a igual anteriormente.","title":"Manualmente"},{"location":"#usando-arquivos","text":"os valores s\u00e3o passados em um arquivo (preferencialmente txt ou csv) com os valores separados por v\u00edrgulas como no exemplo a baixo: 1,2 O sistema cria grafos direcionados e n\u00e3o direcionados com base na op\u00e7\u00e3o escolhida considerando o valor da esquerda como o vertice de sa\u00edda e o da direita como v\u00e9rtice de entrada.","title":"Usando arquivos"},{"location":"#grafos-valorados","text":"Para criar grafos valorados apenas adicione uma coluna a mais com o valor do peso, como no exemplo a baixo: 1,2,40","title":"Grafos valorados"},{"location":"about/","text":"Produ\u00e7\u00e3o Passo divis\u00e3o das tarefas e gasto total de tempo em produ\u00e7\u00e3o de cada membro da equipe Tabela de tempo tabela completa aqui Divis\u00e3o dos requisitos Implementa\u00e7\u00e3o 1- O usu\u00e1rio dever\u00e1 ser capaz de interagir com o sistema para criar um grafo inserindo um item de cada vez (v\u00e9rtices e arestas) (1 pts). > Vin\u00edcius Lima 2- O usu\u00e1rio dever\u00e1 ser capaz de interagir com o sistema para criar um grafo inserindo as informa\u00e7\u00f5es em lote, ou seja, tudo de uma vez s\u00f3, como um arquivo ou um grande string com as informa\u00e7\u00f5es de todos os v\u00e9rtices e arestas (1 pt). > Jo\u00e3o 3- O usu\u00e1rio poder\u00e1 criar grafos direcionados ou n\u00e3o-direcionados, e grafos valorados ou n\u00e3o-valorados (0,5 pts). > Jo\u00e3o 4- O usu\u00e1rio poder\u00e1 ser capaz de imprimir/visualizar o grafo (formato livre a ser definido pelo grupo, poder ser textual como uma lista de adjac\u00eancia, matriz de adjac\u00eancia, etc.) ou gr\u00e1fico como imagem na tela ou download de arquivo de imagem (1 pt). > Jo\u00e3o 5- O usu\u00e1rio dever\u00e1 conseguir obter as informa\u00e7\u00f5es de Ordem e Tamanho do Grafo criado (0,5 pts). > Camila 6- Para um dado v\u00e9rtice o usu\u00e1rio dever\u00e1 ser capaz de obter a informa\u00e7\u00e3o da lista de v\u00e9rtices adjacentes. Se o grafo for direcionado, o sistema dever\u00e1 ser capaz de informar a lista de v\u00e9rtices adjacentes de entrada e a lista de v\u00e9rtices adjacentes de sa\u00edda do dado v\u00e9rtice (0,5 pts). > Vin\u00edcius Lima 7- Para um dado v\u00e9rtice o sistema dever\u00e1 ser capaz de informar o grau daquele v\u00e9rtice. Se o grafo for direcionado, o sistema dever\u00e1 informar o grau de adjac\u00eancia de entrada e de sa\u00edda do v\u00e9rtice (0,5 pts). > Vin\u00edcius Lima 8- Dado um par de v\u00e9rtices, o sistema dever\u00e1 retornar a informa\u00e7\u00e3o se os dois v\u00e9rtices s\u00e3o adjacentes ou n\u00e3o (0,5 pt). > Camila 9- Dado um par de v\u00e9rtices, o sistema dever\u00e1 retornar a informa\u00e7\u00e3o do caminho mais curto entre eles, tanto o valor do custo do menor caminho entre os dois v\u00e9rtices como a sequ\u00eancia de v\u00e9rtices deste menor caminho entre eles. Pode-se considerar que os pesos das arestas s\u00e3o sempre n\u00fameros positivos (n\u00e3o h\u00e1 arestas com pesos negativos) (1,5 pts). > Jo\u00e3o 10- Requisito surpresa a ser divulgado 48 horas antes do prazo final (0,5 pts). > Jo\u00e3o 10.1- Para um dado v\u00e9rtice o usu\u00e1rio dever\u00e1 ser capaz de verificar se o v\u00e9rtice \u00e9 do tipo \"pendente\" (grau igual a 1) ou n\u00e3o. 10.2 -Carregar o grafo relativo a dados dos aeroportos do Brasil no seu sistema (aba \"Grafos\" de Link) Documenta\u00e7\u00e3o Tabela com o total de horas gastos por cada integrante do time para implementar o sistema com a descri\u00e7\u00e3o das atividades (discuss\u00f5es, defini\u00e7\u00e3o do design, implementa\u00e7\u00e3o, testes, escrita da documenta\u00e7\u00e3o, etc\u2026) (0,5 pts). > (j\u00e1 pronto) Descri\u00e7\u00e3o das funcionalidades do sistema, tipo um manual mostrando como cada um dos requisitos acima podem ser usados pelo usu\u00e1rio com printscreens do sistema (1 pt). > Jo\u00e3o Descri\u00e7\u00e3o do c\u00f3digo-fonte, com um link ou arquivo contendo todo o c\u00f3digo-fonte, explicando como foi feita a implementa\u00e7\u00e3o, como fazer o deploy e rodar o sistema. Descri\u00e7\u00e3o das classes, m\u00e9todos, arquivos, APIs, ou que for relevante para entender o c\u00f3digo implementado (1 pt). > Jo\u00e3o","title":"Produ\u00e7\u00e3o"},{"location":"about/#producao","text":"Passo divis\u00e3o das tarefas e gasto total de tempo em produ\u00e7\u00e3o de cada membro da equipe","title":"Produ\u00e7\u00e3o"},{"location":"about/#tabela-de-tempo","text":"tabela completa aqui","title":"Tabela de tempo"},{"location":"about/#divisao-dos-requisitos","text":"","title":"Divis\u00e3o dos requisitos"},{"location":"about/#implementacao","text":"1- O usu\u00e1rio dever\u00e1 ser capaz de interagir com o sistema para criar um grafo inserindo um item de cada vez (v\u00e9rtices e arestas) (1 pts). > Vin\u00edcius Lima 2- O usu\u00e1rio dever\u00e1 ser capaz de interagir com o sistema para criar um grafo inserindo as informa\u00e7\u00f5es em lote, ou seja, tudo de uma vez s\u00f3, como um arquivo ou um grande string com as informa\u00e7\u00f5es de todos os v\u00e9rtices e arestas (1 pt). > Jo\u00e3o 3- O usu\u00e1rio poder\u00e1 criar grafos direcionados ou n\u00e3o-direcionados, e grafos valorados ou n\u00e3o-valorados (0,5 pts). > Jo\u00e3o 4- O usu\u00e1rio poder\u00e1 ser capaz de imprimir/visualizar o grafo (formato livre a ser definido pelo grupo, poder ser textual como uma lista de adjac\u00eancia, matriz de adjac\u00eancia, etc.) ou gr\u00e1fico como imagem na tela ou download de arquivo de imagem (1 pt). > Jo\u00e3o 5- O usu\u00e1rio dever\u00e1 conseguir obter as informa\u00e7\u00f5es de Ordem e Tamanho do Grafo criado (0,5 pts). > Camila 6- Para um dado v\u00e9rtice o usu\u00e1rio dever\u00e1 ser capaz de obter a informa\u00e7\u00e3o da lista de v\u00e9rtices adjacentes. Se o grafo for direcionado, o sistema dever\u00e1 ser capaz de informar a lista de v\u00e9rtices adjacentes de entrada e a lista de v\u00e9rtices adjacentes de sa\u00edda do dado v\u00e9rtice (0,5 pts). > Vin\u00edcius Lima 7- Para um dado v\u00e9rtice o sistema dever\u00e1 ser capaz de informar o grau daquele v\u00e9rtice. Se o grafo for direcionado, o sistema dever\u00e1 informar o grau de adjac\u00eancia de entrada e de sa\u00edda do v\u00e9rtice (0,5 pts). > Vin\u00edcius Lima 8- Dado um par de v\u00e9rtices, o sistema dever\u00e1 retornar a informa\u00e7\u00e3o se os dois v\u00e9rtices s\u00e3o adjacentes ou n\u00e3o (0,5 pt). > Camila 9- Dado um par de v\u00e9rtices, o sistema dever\u00e1 retornar a informa\u00e7\u00e3o do caminho mais curto entre eles, tanto o valor do custo do menor caminho entre os dois v\u00e9rtices como a sequ\u00eancia de v\u00e9rtices deste menor caminho entre eles. Pode-se considerar que os pesos das arestas s\u00e3o sempre n\u00fameros positivos (n\u00e3o h\u00e1 arestas com pesos negativos) (1,5 pts). > Jo\u00e3o 10- Requisito surpresa a ser divulgado 48 horas antes do prazo final (0,5 pts). > Jo\u00e3o 10.1- Para um dado v\u00e9rtice o usu\u00e1rio dever\u00e1 ser capaz de verificar se o v\u00e9rtice \u00e9 do tipo \"pendente\" (grau igual a 1) ou n\u00e3o. 10.2 -Carregar o grafo relativo a dados dos aeroportos do Brasil no seu sistema (aba \"Grafos\" de Link)","title":"Implementa\u00e7\u00e3o"},{"location":"about/#documentacao","text":"Tabela com o total de horas gastos por cada integrante do time para implementar o sistema com a descri\u00e7\u00e3o das atividades (discuss\u00f5es, defini\u00e7\u00e3o do design, implementa\u00e7\u00e3o, testes, escrita da documenta\u00e7\u00e3o, etc\u2026) (0,5 pts). > (j\u00e1 pronto) Descri\u00e7\u00e3o das funcionalidades do sistema, tipo um manual mostrando como cada um dos requisitos acima podem ser usados pelo usu\u00e1rio com printscreens do sistema (1 pt). > Jo\u00e3o Descri\u00e7\u00e3o do c\u00f3digo-fonte, com um link ou arquivo contendo todo o c\u00f3digo-fonte, explicando como foi feita a implementa\u00e7\u00e3o, como fazer o deploy e rodar o sistema. Descri\u00e7\u00e3o das classes, m\u00e9todos, arquivos, APIs, ou que for relevante para entender o c\u00f3digo implementado (1 pt). > Jo\u00e3o","title":"Documenta\u00e7\u00e3o"},{"location":"arquivos/","text":"Arquivos Breve explica\u00e7\u00e3o sobre os arquivos presentes no projeto Makefile Cont\u00e9m os atalhos para ajudar a rodar o projeto com mais facilidade all: run run: python3 main.py save: pip freeze > requirements.txt import: pip install -r requirements.txt venv: python3 -m venv graf _vizualize.py Cont\u00e9m as principais fun\u00e7\u00f5es do programa e imports main.py Cont\u00e9m o c\u00f3digo por tr\u00e1s das escolhas do usu\u00e1rio requirements.txt Cont\u00e9m os requisitos para executar o programa peso,voos,arquivo.txt Cont\u00e9m valores para teste do projeto e podem ser modificados seguindo as regras arquivo.txt : para grafos n\u00e3o valorados peso,voos.txt : para grafos valorados","title":"Arquivos"},{"location":"arquivos/#arquivos","text":"Breve explica\u00e7\u00e3o sobre os arquivos presentes no projeto","title":"Arquivos"},{"location":"arquivos/#makefile","text":"Cont\u00e9m os atalhos para ajudar a rodar o projeto com mais facilidade all: run run: python3 main.py save: pip freeze > requirements.txt import: pip install -r requirements.txt venv: python3 -m venv graf","title":"Makefile"},{"location":"arquivos/#_vizualizepy","text":"Cont\u00e9m as principais fun\u00e7\u00f5es do programa e imports","title":"_vizualize.py"},{"location":"arquivos/#mainpy","text":"Cont\u00e9m o c\u00f3digo por tr\u00e1s das escolhas do usu\u00e1rio","title":"main.py"},{"location":"arquivos/#requirementstxt","text":"Cont\u00e9m os requisitos para executar o programa","title":"requirements.txt"},{"location":"arquivos/#pesovoosarquivotxt","text":"Cont\u00e9m valores para teste do projeto e podem ser modificados seguindo as regras arquivo.txt : para grafos n\u00e3o valorados peso,voos.txt : para grafos valorados","title":"peso,voos,arquivo.txt"},{"location":"func/","text":"Todas as fun\u00e7\u00f5es do c\u00f3digo Breve descri\u00e7\u00e3o contendo todos os arquivos de c\u00f3digo do projeto e suas fun\u00e7\u00f5es c\u00f3digo fonte e demais arquivos usados para teste aqui main.py Menu da aplica\u00e7\u00e3o, respons\u00e1vel por toda l\u00f3gica do programa def menu(): print(\"Bem-vindo ao nosso Sistema de Grafos!\\n\") option = 0 while(option != 9): print(MENU_STRING) option = int(input(\"Digite a op\u00e7\u00e3o desejada: \")) if (option == 1): G = nx.Graph() flag = 0 while(flag != '$'): flag = input(\"Digite '$' para parar de digitar as arestas \") if(flag != '$'): G.add_node(flag) flag1 = 0 flag2 = 0 while(flag1 != '$' or flag2 != '$'): flag1 = input(\"Digite '$' para parar de digitar os vertices ou digite a primeira aresta \") flag2 = input(\"Digite '$' para parar de digitar os vertices ou digite a segunda aresta \") if(flag != '$' or flag2 != '$'): G.add_edge(flag1, flag2) nx.draw_networkx(G) plt.show() sp = G direcionado = 0 valorado = 0 elif (option == 2): direcionado = int(input(\"digite 1 para direcionado 0 para n\u00e3o direcionado: \")) valorado = int(input(\"digite 1 para valorado 0 para n\u00e3o valorado: \")) while True: try: arquivo = input('Digite o nome do arquivo (acompanhado do formato): ') with open(arquivo) as f: contents = f.read() except FileNotFoundError: print(\"nome incorreto do arquivo ou arquivo nao encontrado\") continue break removn = contents.split('\\n') if valorado == 0: for i in removn: a = i.split() b= a[0].split(',') grafo.addEdge(b[0],b[1]) else: for i in removn: a = i.split() b= a[0].split(',') grafo.addWeigEdge(b[0],b[1],float(b[2])) sp = grafo.visualize(direcionado,valorado) elif (option == 3): grafo.getOrder(sp) elif (option == 4): grafo.getSize(sp) elif (option == 5): if direcionado == 0: grafo.isAdj(sp) else: grafo.isAdjD(sp) elif (option == 6): if direcionado == 0: grafo.grauV(sp) else: grafo.grauVD(sp) elif(option == 7): grafo.Nodeconected(sp) elif (option == 8): if valorado == 0: grafo.shortP(sp) else: grafo.shortPV(sp) _vizualize.py init lista de arrays vazios que ser\u00e3o populados pelos valores passados pelo usu\u00e1rio def __init__(self): self.visual = [] // array para grafos n\u00e3o valorados self.Wvisual = [] // array para grafos valorados addEdge Recebe dois elementos e adiciona em um array vazio para criar um grafo n\u00e3o valorado def addEdge(self, a, b): \"\"\" Args: a (any): primeiro vertice b (any): segundo vertice \"\"\" temp = [a, b] self.visual.append(temp) addWeigEdge Recebe tr\u00eas elementos e adiciona em um array vazio para criar um grafo valorado def addWeigEdge(self, a, b, c): \"\"\" Args: a (any): primeiro vertice b (any): segundo vertice c (number): peso da aresta \"\"\" temp = [a, b, c] self.Wvisual.append(temp) Nodeconected Recebe um grafo para uma verifica\u00e7\u00e3o de conex\u00e3o e diz se os dois vertices est\u00e3o conectados def Nodeconected(self,grafo): \"\"\" Args: grafo (graph): Grafo preenchido com os valores \"\"\" u = input('v1: ') v = input('v2: ') if u in grafo.neighbors(v): print(u,'e',v,'Sao vizinhos\\n') else: print(u, 'e',v,'Nao sao vizinhos\\n') grauV Recebe um grafo para uma checagem de grau e pendencia para um grafo n\u00e3o direcionado e no final diz o grau e se um vertice \u00e9 pendente ou n\u00e3o def grauV(self,grafo): \"\"\" Args: grafo (graph): Grafo preenchido com os valores \"\"\" variavel = input(\"Vertice: \") gr = grafo.degree[variavel] print('grau do vertice:',gr) if gr == 1: print(\"pendente\\n\") else: print('nao pendente\\n') grauVD Recebe um grafo para uma checagem de grau e pendencia para um grafo direcionado e no final diz o grau de entrada e sa\u00edda e se um vertice \u00e9 pendente ou n\u00e3o def grauVD(self,grafo): \"\"\" Args: grafo (graph): Grafo preenchido com os valores \"\"\" variavel = input(\"Vertice: \") gr = grafo.degree[variavel] print('grau de entrada: ',grafo.in_degree(variavel)) print('grau de saida: ',grafo.out_degree(variavel)) if gr == 1: print(\"pendente\\n\") else: print('nao pendente\\n') isAdj Checa os vertices adjacentes ao vertice passado de um grafo n\u00e3o direcionado e retorna a lista com todos def isAdj(self,grafo): \"\"\" Args: grafo (graph): Grafo preenchido com os valores \"\"\" variavel = input(\"Digite o vertice que deseja verificar: \") print('vertices adjacentes: ',grafo.edges(variavel)) isAdjD Checa os vertices adjacentes ao vertice passado de um grafo direcionado e retorna a lista com todos separados por entrada e sa\u00edda def isAdjD(self,grafo): \"\"\" Args: grafo (graph): Grafo preenchido com os valores \"\"\" variavel = input(\"Digite o vertice que deseja verificar: \") print('vertices adjacentes de entrada: ',grafo.in_edges(variavel)) print('vertices adjacentes de saida: ',grafo.out_edges(variavel),'\\n') shortP Checa o menor caminho entre dois vertices de um grafo n\u00e3o valorado e retorna uma lista de v1 a v2 def shortP(self,grafo): \"\"\" Args: grafo (graph): Grafo preenchido com os valores \"\"\" try: t1 = input('de: ') t2 = input('para: ') sp= nx.shortest_path(grafo,t1,t2) print('menor caminho de',t1,'para',t2,':',sp,\"\\n\") except nx.NetworkXNoPath: print(\"n\u00e3o existem caminhos de\",t1,\"ate\", t2,'\\n') shortPV Checa o menor caminho entre dois vertices de um grafo valorado e retorna uma lista de v1 a v2 e o custo total do caminho def shortPV(self,grafo): \"\"\" Args: grafo (graph): Grafo preenchido com os valores \"\"\" try: t1 = input('de: ') t2 = input('para: ') sp= nx.single_source_dijkstra(grafo,t1,t2) print('menor caminho de',t1,'para',t2,':',sp,\"\\n\") except nx.NetworkXNoPath: print(\"n\u00e3o existem caminhos de\",t1,\"ate\", t2,'\\n') getOrder e getSize Recebe um grafo, retorna sua ordem e tamanho def getOrder(self,grafo): \"\"\" Args: grafo (graph): Grafo preenchido com os valores \"\"\" print('ordem do grafo:',grafo.order(),'\\n') def getSize(self,grafo): \"\"\" Args: grafo (graph): Grafo preenchido com os valores \"\"\" print('tamanho do grafo: ',grafo.size(),'\\n') visualize Fun\u00e7\u00e3o principal do programa, respons\u00e1vel por montar, exibir e retornar o grafo passado pelo usu\u00e1rio dependendo do tipo de grafo def visualize(self,directed,weighted): \"\"\" Args: directed (int): Informa se um grafo \u00e9 direcionado ou n\u00e3o weighted (int): Informa se um grafo \u00e9 valorado ou n\u00e3o Returns: grafo: Retorna um grafo preenchido com os valores passados pelo usu\u00e1rio \"\"\" if directed == 0: if weighted == 0: G = nx.Graph() G.add_edges_from(self.visual) nx.draw_networkx(G) plt.show() return G else: G = nx.Graph() G.add_weighted_edges_from(self.Wvisual) pos=nx.spring_layout(G) nx.draw_networkx(G,pos) labels = nx.get_edge_attributes(G,'weight') nx.draw_networkx_edge_labels(G,pos,edge_labels=labels) plt.show() return G else: if weighted == 0: DG = nx.DiGraph() DG.add_edges_from(self.visual) nx.draw_networkx(DG) plt.show() return DG else: DG = nx.DiGraph() DG.add_weighted_edges_from(self.Wvisual) pos=nx.spring_layout(DG) nx.draw_networkx(DG,pos) labels = nx.get_edge_attributes(DG,'weight') nx.draw_networkx_edge_labels(DG,pos,edge_labels=labels) plt.show() return DG","title":"Functions"},{"location":"func/#todas-as-funcoes-do-codigo","text":"Breve descri\u00e7\u00e3o contendo todos os arquivos de c\u00f3digo do projeto e suas fun\u00e7\u00f5es c\u00f3digo fonte e demais arquivos usados para teste aqui","title":"Todas as fun\u00e7\u00f5es do c\u00f3digo"},{"location":"func/#mainpy","text":"Menu da aplica\u00e7\u00e3o, respons\u00e1vel por toda l\u00f3gica do programa def menu(): print(\"Bem-vindo ao nosso Sistema de Grafos!\\n\") option = 0 while(option != 9): print(MENU_STRING) option = int(input(\"Digite a op\u00e7\u00e3o desejada: \")) if (option == 1): G = nx.Graph() flag = 0 while(flag != '$'): flag = input(\"Digite '$' para parar de digitar as arestas \") if(flag != '$'): G.add_node(flag) flag1 = 0 flag2 = 0 while(flag1 != '$' or flag2 != '$'): flag1 = input(\"Digite '$' para parar de digitar os vertices ou digite a primeira aresta \") flag2 = input(\"Digite '$' para parar de digitar os vertices ou digite a segunda aresta \") if(flag != '$' or flag2 != '$'): G.add_edge(flag1, flag2) nx.draw_networkx(G) plt.show() sp = G direcionado = 0 valorado = 0 elif (option == 2): direcionado = int(input(\"digite 1 para direcionado 0 para n\u00e3o direcionado: \")) valorado = int(input(\"digite 1 para valorado 0 para n\u00e3o valorado: \")) while True: try: arquivo = input('Digite o nome do arquivo (acompanhado do formato): ') with open(arquivo) as f: contents = f.read() except FileNotFoundError: print(\"nome incorreto do arquivo ou arquivo nao encontrado\") continue break removn = contents.split('\\n') if valorado == 0: for i in removn: a = i.split() b= a[0].split(',') grafo.addEdge(b[0],b[1]) else: for i in removn: a = i.split() b= a[0].split(',') grafo.addWeigEdge(b[0],b[1],float(b[2])) sp = grafo.visualize(direcionado,valorado) elif (option == 3): grafo.getOrder(sp) elif (option == 4): grafo.getSize(sp) elif (option == 5): if direcionado == 0: grafo.isAdj(sp) else: grafo.isAdjD(sp) elif (option == 6): if direcionado == 0: grafo.grauV(sp) else: grafo.grauVD(sp) elif(option == 7): grafo.Nodeconected(sp) elif (option == 8): if valorado == 0: grafo.shortP(sp) else: grafo.shortPV(sp)","title":"main.py"},{"location":"func/#_vizualizepy","text":"","title":"_vizualize.py"},{"location":"func/#init","text":"lista de arrays vazios que ser\u00e3o populados pelos valores passados pelo usu\u00e1rio def __init__(self): self.visual = [] // array para grafos n\u00e3o valorados self.Wvisual = [] // array para grafos valorados","title":"init"},{"location":"func/#addedge","text":"Recebe dois elementos e adiciona em um array vazio para criar um grafo n\u00e3o valorado def addEdge(self, a, b): \"\"\" Args: a (any): primeiro vertice b (any): segundo vertice \"\"\" temp = [a, b] self.visual.append(temp)","title":"addEdge"},{"location":"func/#addweigedge","text":"Recebe tr\u00eas elementos e adiciona em um array vazio para criar um grafo valorado def addWeigEdge(self, a, b, c): \"\"\" Args: a (any): primeiro vertice b (any): segundo vertice c (number): peso da aresta \"\"\" temp = [a, b, c] self.Wvisual.append(temp)","title":"addWeigEdge"},{"location":"func/#nodeconected","text":"Recebe um grafo para uma verifica\u00e7\u00e3o de conex\u00e3o e diz se os dois vertices est\u00e3o conectados def Nodeconected(self,grafo): \"\"\" Args: grafo (graph): Grafo preenchido com os valores \"\"\" u = input('v1: ') v = input('v2: ') if u in grafo.neighbors(v): print(u,'e',v,'Sao vizinhos\\n') else: print(u, 'e',v,'Nao sao vizinhos\\n')","title":"Nodeconected"},{"location":"func/#grauv","text":"Recebe um grafo para uma checagem de grau e pendencia para um grafo n\u00e3o direcionado e no final diz o grau e se um vertice \u00e9 pendente ou n\u00e3o def grauV(self,grafo): \"\"\" Args: grafo (graph): Grafo preenchido com os valores \"\"\" variavel = input(\"Vertice: \") gr = grafo.degree[variavel] print('grau do vertice:',gr) if gr == 1: print(\"pendente\\n\") else: print('nao pendente\\n')","title":"grauV"},{"location":"func/#grauvd","text":"Recebe um grafo para uma checagem de grau e pendencia para um grafo direcionado e no final diz o grau de entrada e sa\u00edda e se um vertice \u00e9 pendente ou n\u00e3o def grauVD(self,grafo): \"\"\" Args: grafo (graph): Grafo preenchido com os valores \"\"\" variavel = input(\"Vertice: \") gr = grafo.degree[variavel] print('grau de entrada: ',grafo.in_degree(variavel)) print('grau de saida: ',grafo.out_degree(variavel)) if gr == 1: print(\"pendente\\n\") else: print('nao pendente\\n')","title":"grauVD"},{"location":"func/#isadj","text":"Checa os vertices adjacentes ao vertice passado de um grafo n\u00e3o direcionado e retorna a lista com todos def isAdj(self,grafo): \"\"\" Args: grafo (graph): Grafo preenchido com os valores \"\"\" variavel = input(\"Digite o vertice que deseja verificar: \") print('vertices adjacentes: ',grafo.edges(variavel))","title":"isAdj"},{"location":"func/#isadjd","text":"Checa os vertices adjacentes ao vertice passado de um grafo direcionado e retorna a lista com todos separados por entrada e sa\u00edda def isAdjD(self,grafo): \"\"\" Args: grafo (graph): Grafo preenchido com os valores \"\"\" variavel = input(\"Digite o vertice que deseja verificar: \") print('vertices adjacentes de entrada: ',grafo.in_edges(variavel)) print('vertices adjacentes de saida: ',grafo.out_edges(variavel),'\\n')","title":"isAdjD"},{"location":"func/#shortp","text":"Checa o menor caminho entre dois vertices de um grafo n\u00e3o valorado e retorna uma lista de v1 a v2 def shortP(self,grafo): \"\"\" Args: grafo (graph): Grafo preenchido com os valores \"\"\" try: t1 = input('de: ') t2 = input('para: ') sp= nx.shortest_path(grafo,t1,t2) print('menor caminho de',t1,'para',t2,':',sp,\"\\n\") except nx.NetworkXNoPath: print(\"n\u00e3o existem caminhos de\",t1,\"ate\", t2,'\\n')","title":"shortP"},{"location":"func/#shortpv","text":"Checa o menor caminho entre dois vertices de um grafo valorado e retorna uma lista de v1 a v2 e o custo total do caminho def shortPV(self,grafo): \"\"\" Args: grafo (graph): Grafo preenchido com os valores \"\"\" try: t1 = input('de: ') t2 = input('para: ') sp= nx.single_source_dijkstra(grafo,t1,t2) print('menor caminho de',t1,'para',t2,':',sp,\"\\n\") except nx.NetworkXNoPath: print(\"n\u00e3o existem caminhos de\",t1,\"ate\", t2,'\\n')","title":"shortPV"},{"location":"func/#getorder-e-getsize","text":"Recebe um grafo, retorna sua ordem e tamanho def getOrder(self,grafo): \"\"\" Args: grafo (graph): Grafo preenchido com os valores \"\"\" print('ordem do grafo:',grafo.order(),'\\n') def getSize(self,grafo): \"\"\" Args: grafo (graph): Grafo preenchido com os valores \"\"\" print('tamanho do grafo: ',grafo.size(),'\\n')","title":"getOrder e getSize"},{"location":"func/#visualize","text":"Fun\u00e7\u00e3o principal do programa, respons\u00e1vel por montar, exibir e retornar o grafo passado pelo usu\u00e1rio dependendo do tipo de grafo def visualize(self,directed,weighted): \"\"\" Args: directed (int): Informa se um grafo \u00e9 direcionado ou n\u00e3o weighted (int): Informa se um grafo \u00e9 valorado ou n\u00e3o Returns: grafo: Retorna um grafo preenchido com os valores passados pelo usu\u00e1rio \"\"\" if directed == 0: if weighted == 0: G = nx.Graph() G.add_edges_from(self.visual) nx.draw_networkx(G) plt.show() return G else: G = nx.Graph() G.add_weighted_edges_from(self.Wvisual) pos=nx.spring_layout(G) nx.draw_networkx(G,pos) labels = nx.get_edge_attributes(G,'weight') nx.draw_networkx_edge_labels(G,pos,edge_labels=labels) plt.show() return G else: if weighted == 0: DG = nx.DiGraph() DG.add_edges_from(self.visual) nx.draw_networkx(DG) plt.show() return DG else: DG = nx.DiGraph() DG.add_weighted_edges_from(self.Wvisual) pos=nx.spring_layout(DG) nx.draw_networkx(DG,pos) labels = nx.get_edge_attributes(DG,'weight') nx.draw_networkx_edge_labels(DG,pos,edge_labels=labels) plt.show() return DG","title":"visualize"}]}